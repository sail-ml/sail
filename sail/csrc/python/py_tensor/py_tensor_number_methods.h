/*
################################################################################
#                  THIS CODE IS AUTOGENERATED FROM A TEMPLATE                  #
#                 TO MAKE CHANGES, EDIT THE ORIGINAL .src FILE                 #
################################################################################
*/

#pragma once

#include <Python.h>
#include <structmember.h>
#include <chrono>
#include <iostream>
#include "../../src/Tensor.h"
#include "../../src/dtypes.h"
#include "../../src/error.h"
#include "../macros.h"
#include "../ops/elementwise.h"
#include "numpy/arrayobject.h"
#include "py_tensor.h"

RETURN_OBJECT PyDimensionError;

/** begin block
 * name = [add, sub, mul, truediv]
 * op = [+, -, *, /]
 */


RETURN_OBJECT PyTensor_add(PyObject *t1, PyObject *t2) {
    sail::Tensor tensor1;
    sail::Tensor tensor2;

    NUMERIC_PROCESS(t1, t2);

    PyTensor *ret_class;
    ret_class = (PyTensor *)PyTensorType.tp_alloc(&PyTensorType, 0);

    ret_class->tensor = tensor1 + tensor2;

    ret_class->ndim = ret_class->tensor.get_ndim();
    ret_class->requires_grad = ret_class->tensor.requires_grad;
    // SET_BASE(t1, ret_class);

    return (PyObject *)ret_class;
}



RETURN_OBJECT PyTensor_sub(PyObject *t1, PyObject *t2) {
    sail::Tensor tensor1;
    sail::Tensor tensor2;

    NUMERIC_PROCESS(t1, t2);

    PyTensor *ret_class;
    ret_class = (PyTensor *)PyTensorType.tp_alloc(&PyTensorType, 0);

    ret_class->tensor = tensor1 - tensor2;

    ret_class->ndim = ret_class->tensor.get_ndim();
    ret_class->requires_grad = ret_class->tensor.requires_grad;
    // SET_BASE(t1, ret_class);

    return (PyObject *)ret_class;
}



RETURN_OBJECT PyTensor_mul(PyObject *t1, PyObject *t2) {
    sail::Tensor tensor1;
    sail::Tensor tensor2;

    NUMERIC_PROCESS(t1, t2);

    PyTensor *ret_class;
    ret_class = (PyTensor *)PyTensorType.tp_alloc(&PyTensorType, 0);

    ret_class->tensor = tensor1 * tensor2;

    ret_class->ndim = ret_class->tensor.get_ndim();
    ret_class->requires_grad = ret_class->tensor.requires_grad;
    // SET_BASE(t1, ret_class);

    return (PyObject *)ret_class;
}



RETURN_OBJECT PyTensor_truediv(PyObject *t1, PyObject *t2) {
    sail::Tensor tensor1;
    sail::Tensor tensor2;

    NUMERIC_PROCESS(t1, t2);

    PyTensor *ret_class;
    ret_class = (PyTensor *)PyTensorType.tp_alloc(&PyTensorType, 0);

    ret_class->tensor = tensor1 / tensor2;

    ret_class->ndim = ret_class->tensor.get_ndim();
    ret_class->requires_grad = ret_class->tensor.requires_grad;
    // SET_BASE(t1, ret_class);

    return (PyObject *)ret_class;
}

/** end block **/
