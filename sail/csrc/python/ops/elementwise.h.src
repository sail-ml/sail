#pragma once

#include <Python.h>
#include <structmember.h>
#include <chrono>
#include <iostream>
#include "../py_tensor/py_tensor.h"
#include "core/Tensor.h"
#include "core/dtypes.h"
#include "core/factories.h"
#include "core/ops/ops.h"
#include "numpy/arrayobject.h"

#include "../error_defs.h"
#include "../macros.h"
#include "../py_utils.h"

// /** begin block
//  * name = [add, sub, mul, div]
//  * fname = [add, subtract, multiply, divide]
//  * op = [+, -, *, /]
//  */

// RETURN_OBJECT ops_$name$(PyObject* self, PyObject* args) {
//     START_EXCEPTION_HANDLING
//     PyObject* t1;
//     PyObject* t2;

//     sail::Tensor tensor1;
//     sail::Tensor tensor2;

//     if (!PyArg_ParseTuple(args, "OO", &t1, &t2)) {
//         PyErr_SetString(PyExc_TypeError, "Inputs should be Sail Tensors");
//         return nullptr;
//     }

//     PyTensor* ret_class;
//     ret_class = (PyTensor*)PyTensorType.tp_alloc(&PyTensorType, 0);

//     ret_class->tensor =
//         sail::ops::$fname$(((PyTensor*)t1)->tensor, ((PyTensor*)t2)->tensor);

//     return (PyObject*)ret_class;
//     END_EXCEPTION_HANDLING
// }

/** end block **/

RETURN_OBJECT cast_int32(PyObject* unused, PyObject* args) {
    START_EXCEPTION_HANDLING
    PyObject* t1;

    sail::Tensor tensor1;

    if (!PyArg_ParseTuple(args, "O!", &PyTensorType, &t1)) {
        PyErr_SetString(PyExc_TypeError, "Inputs should be Sail Tensors");
        return nullptr;
    }

    tensor1 = ((PyTensor*)t1)->tensor.cast(Dtype::sInt32);
    PyTensor* ret_class;
    ret_class = (PyTensor*)PyTensorType.tp_alloc(&PyTensorType, 0);

    ret_class->tensor = tensor1;

    return (PyObject*)ret_class;
    END_EXCEPTION_HANDLING
}