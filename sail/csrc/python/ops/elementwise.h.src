#pragma once

#include <Python.h>
#include <structmember.h>
#include <chrono>
#include <iostream>
#include "../../core/Tensor.h"
#include "../../core/dtypes.h"
#include "../../core/factories.h"
#include "../../core/ops/ops.h"
#include "../py_tensor/py_tensor.h"
#include "numpy/arrayobject.h"

#include "../macros.h"

/** begin block
 * name = [add, sub, mul, div]
 * fname = [add, subtract, multiply, divide]
 * op = [+, -, *, /]
 */

RETURN_OBJECT ops_$name$(PyObject* self, PyObject* args) {
    PyObject* t1;
    PyObject* t2;

    sail::Tensor tensor1;
    sail::Tensor tensor2;

    if (!PyArg_ParseTuple(args, "OO", &t1, &t2)) {
        PyErr_SetString(PyExc_TypeError, "Inputs should be Sail Tensors");
        return NULL;
    }

    NUMERIC_PROCESS(t1, t2);

    PyTensor* ret_class;
    ret_class = (PyTensor*)PyTensorType.tp_alloc(&PyTensorType, 0);

    ret_class->tensor =
        sail::ops::$fname$(((PyTensor*)t1)->tensor, ((PyTensor*)t2)->tensor);
    // std::cout << (ret_class->tensor.fcn)->getName() << std::endl;

    ret_class->ndim = ret_class->tensor.get_ndim();
    ret_class->dtype = ((PyTensor*)t1)->dtype;
    ret_class->requires_grad = ret_class->tensor.requires_grad;
    // SET_BASE(t1, ret_class);

    return (PyObject*)ret_class;
}

/** end block **/

RETURN_OBJECT cast_int32(PyObject* unused, PyObject* args) {
    PyObject* t1;

    sail::Tensor tensor1;

    if (!PyArg_ParseTuple(args, "O!", &PyTensorType, &t1)) {
        PyErr_SetString(PyExc_TypeError, "Inputs should be Sail Tensors");
        return NULL;
    }

    tensor1 = ((PyTensor*)t1)->tensor.cast(Dtype::sInt32);
    PyTensor* ret_class;
    ret_class = (PyTensor*)PyTensorType.tp_alloc(&PyTensorType, 0);

    ret_class->tensor = tensor1;

    ret_class->ndim = ret_class->tensor.get_ndim();
    ret_class->dtype = 5;

    return (PyObject*)ret_class;
}