/*
################################################################################
#                  THIS CODE IS AUTOGENERATED FROM A TEMPLATE                  #
#                 TO MAKE CHANGES, EDIT THE ORIGINAL .src FILE                 #
################################################################################
*/

#pragma once

#include <immintrin.h>
#include <cassert>  // needed for xsimd
#include "../../Tensor.h"
#include "../base.h"
#include "../elementwise.h"
#include "xsimd/xsimd.hpp"
namespace sail {

/** begin block
 * name = [Add, Sub, Multiply, Divide]
 * baseOp = [+, -, *, /]
 * avxOp = [add, sub, mul, div]
 */


class AddTTKernel : public Kernel {
   public:
    void execute(const Tensor& t1, const Tensor& t2, const Tensor& out_tensor,
                 bool broadcast) {
        launch_arithmetic(t1.get_dtype(), [&](auto pt) {
            using DtypeType = decltype(pt);
            using T = typename DtypeType::type;

            using avx_type = xsimd::simd_type<T>;

            struct Impl {
                inline void call_base(T& x1, T& x2, T& out) {
                    out = x1 + x2;
                }
                inline void call_avx_aligned(T* x1, T* x2, T* out) {
                    avx_type a = xsimd::load_aligned(x1);
                    avx_type b = xsimd::load_aligned(x2);
                    auto c = a + b;
                    xsimd::store_aligned(out, c);
                }

                inline void call_avx_non_aligned(T* x1, T* x2, T* out) {
                    avx_type a = xsimd::load_unaligned(x1);
                    avx_type b = xsimd::load_unaligned(x2);
                    auto c = a + b;
                    xsimd::store_unaligned(out, c);
                }
            };
            BinaryElementwise<T, T, T>(Impl{}, broadcast, t1, t2, out_tensor);
        });
    }
};



class SubTTKernel : public Kernel {
   public:
    void execute(const Tensor& t1, const Tensor& t2, const Tensor& out_tensor,
                 bool broadcast) {
        launch_arithmetic(t1.get_dtype(), [&](auto pt) {
            using DtypeType = decltype(pt);
            using T = typename DtypeType::type;

            using avx_type = xsimd::simd_type<T>;

            struct Impl {
                inline void call_base(T& x1, T& x2, T& out) {
                    out = x1 - x2;
                }
                inline void call_avx_aligned(T* x1, T* x2, T* out) {
                    avx_type a = xsimd::load_aligned(x1);
                    avx_type b = xsimd::load_aligned(x2);
                    auto c = a - b;
                    xsimd::store_aligned(out, c);
                }

                inline void call_avx_non_aligned(T* x1, T* x2, T* out) {
                    avx_type a = xsimd::load_unaligned(x1);
                    avx_type b = xsimd::load_unaligned(x2);
                    auto c = a - b;
                    xsimd::store_unaligned(out, c);
                }
            };
            BinaryElementwise<T, T, T>(Impl{}, broadcast, t1, t2, out_tensor);
        });
    }
};



class MultiplyTTKernel : public Kernel {
   public:
    void execute(const Tensor& t1, const Tensor& t2, const Tensor& out_tensor,
                 bool broadcast) {
        launch_arithmetic(t1.get_dtype(), [&](auto pt) {
            using DtypeType = decltype(pt);
            using T = typename DtypeType::type;

            using avx_type = xsimd::simd_type<T>;

            struct Impl {
                inline void call_base(T& x1, T& x2, T& out) {
                    out = x1 * x2;
                }
                inline void call_avx_aligned(T* x1, T* x2, T* out) {
                    avx_type a = xsimd::load_aligned(x1);
                    avx_type b = xsimd::load_aligned(x2);
                    auto c = a * b;
                    xsimd::store_aligned(out, c);
                }

                inline void call_avx_non_aligned(T* x1, T* x2, T* out) {
                    avx_type a = xsimd::load_unaligned(x1);
                    avx_type b = xsimd::load_unaligned(x2);
                    auto c = a * b;
                    xsimd::store_unaligned(out, c);
                }
            };
            BinaryElementwise<T, T, T>(Impl{}, broadcast, t1, t2, out_tensor);
        });
    }
};



class DivideTTKernel : public Kernel {
   public:
    void execute(const Tensor& t1, const Tensor& t2, const Tensor& out_tensor,
                 bool broadcast) {
        launch_arithmetic(t1.get_dtype(), [&](auto pt) {
            using DtypeType = decltype(pt);
            using T = typename DtypeType::type;

            using avx_type = xsimd::simd_type<T>;

            struct Impl {
                inline void call_base(T& x1, T& x2, T& out) {
                    out = x1 / x2;
                }
                inline void call_avx_aligned(T* x1, T* x2, T* out) {
                    avx_type a = xsimd::load_aligned(x1);
                    avx_type b = xsimd::load_aligned(x2);
                    auto c = a / b;
                    xsimd::store_aligned(out, c);
                }

                inline void call_avx_non_aligned(T* x1, T* x2, T* out) {
                    avx_type a = xsimd::load_unaligned(x1);
                    avx_type b = xsimd::load_unaligned(x2);
                    auto c = a / b;
                    xsimd::store_unaligned(out, c);
                }
            };
            BinaryElementwise<T, T, T>(Impl{}, broadcast, t1, t2, out_tensor);
        });
    }
};

/** end block **/

/** begin block
 * name = [Add, Sub, Multiply, Divide]
 * baseOp = [+, -, *, /]
 * avxOp = [add, sub, mul, div]
 */


class AddTSKernel : public Kernel {
   public:
    void execute(const Tensor& t1, const Tensor& t2, Tensor& out_tensor,
                 bool broadcast) {
        launch_arithmetic(t1.get_dtype(), [&](auto pt) {
            using T = typename decltype(pt)::type;
            using avx_type = xsimd::simd_type<T>;

            struct Impl {
                inline void call_base(T x1, T x2, T& out) {
                    out = x1 + x2;
                }
                inline void call_avx_aligned(T* x1, T* x2, T* out) {
                    avx_type a = xsimd::load_aligned(x1);
                    avx_type b = xsimd::load_aligned(x2);
                    auto c = a + b;
                    xsimd::store_aligned(out, c);
                }

                inline void call_avx_non_aligned(T* x1, T* x2, T* out) {
                    avx_type a = xsimd::load_unaligned(x1);
                    avx_type b = xsimd::load_unaligned(x2);
                    auto c = a + b;
                    xsimd::store_unaligned(out, c);
                }
            };

            BinaryElementwiseScalar<T, T, T>(Impl{}, t1, t2, out_tensor);
        });
    }
};



class SubTSKernel : public Kernel {
   public:
    void execute(const Tensor& t1, const Tensor& t2, Tensor& out_tensor,
                 bool broadcast) {
        launch_arithmetic(t1.get_dtype(), [&](auto pt) {
            using T = typename decltype(pt)::type;
            using avx_type = xsimd::simd_type<T>;

            struct Impl {
                inline void call_base(T x1, T x2, T& out) {
                    out = x1 - x2;
                }
                inline void call_avx_aligned(T* x1, T* x2, T* out) {
                    avx_type a = xsimd::load_aligned(x1);
                    avx_type b = xsimd::load_aligned(x2);
                    auto c = a - b;
                    xsimd::store_aligned(out, c);
                }

                inline void call_avx_non_aligned(T* x1, T* x2, T* out) {
                    avx_type a = xsimd::load_unaligned(x1);
                    avx_type b = xsimd::load_unaligned(x2);
                    auto c = a - b;
                    xsimd::store_unaligned(out, c);
                }
            };

            BinaryElementwiseScalar<T, T, T>(Impl{}, t1, t2, out_tensor);
        });
    }
};



class MultiplyTSKernel : public Kernel {
   public:
    void execute(const Tensor& t1, const Tensor& t2, Tensor& out_tensor,
                 bool broadcast) {
        launch_arithmetic(t1.get_dtype(), [&](auto pt) {
            using T = typename decltype(pt)::type;
            using avx_type = xsimd::simd_type<T>;

            struct Impl {
                inline void call_base(T x1, T x2, T& out) {
                    out = x1 * x2;
                }
                inline void call_avx_aligned(T* x1, T* x2, T* out) {
                    avx_type a = xsimd::load_aligned(x1);
                    avx_type b = xsimd::load_aligned(x2);
                    auto c = a * b;
                    xsimd::store_aligned(out, c);
                }

                inline void call_avx_non_aligned(T* x1, T* x2, T* out) {
                    avx_type a = xsimd::load_unaligned(x1);
                    avx_type b = xsimd::load_unaligned(x2);
                    auto c = a * b;
                    xsimd::store_unaligned(out, c);
                }
            };

            BinaryElementwiseScalar<T, T, T>(Impl{}, t1, t2, out_tensor);
        });
    }
};



class DivideTSKernel : public Kernel {
   public:
    void execute(const Tensor& t1, const Tensor& t2, Tensor& out_tensor,
                 bool broadcast) {
        launch_arithmetic(t1.get_dtype(), [&](auto pt) {
            using T = typename decltype(pt)::type;
            using avx_type = xsimd::simd_type<T>;

            struct Impl {
                inline void call_base(T x1, T x2, T& out) {
                    out = x1 / x2;
                }
                inline void call_avx_aligned(T* x1, T* x2, T* out) {
                    avx_type a = xsimd::load_aligned(x1);
                    avx_type b = xsimd::load_aligned(x2);
                    auto c = a / b;
                    xsimd::store_aligned(out, c);
                }

                inline void call_avx_non_aligned(T* x1, T* x2, T* out) {
                    avx_type a = xsimd::load_unaligned(x1);
                    avx_type b = xsimd::load_unaligned(x2);
                    auto c = a / b;
                    xsimd::store_unaligned(out, c);
                }
            };

            BinaryElementwiseScalar<T, T, T>(Impl{}, t1, t2, out_tensor);
        });
    }
};

/** end block **/

}  // namespace sail
