/*
################################################################################
#                  THIS CODE IS AUTOGENERATED FROM A TEMPLATE                  #
#                 TO MAKE CHANGES, EDIT THE ORIGINAL .src FILE                 #
################################################################################
*/

#include <iostream>

#include "elementwise.h"
#include "../Tensor.h"
#include "../Tensor_storage.h"
#include "../kernels/kernel.h"

#include "../factories.h"


namespace sail {

namespace ops {


/** begin block 
 * name = [add, subtract, divide, multiply]
 * kName = [Add, Sub, Divide, Multiply]
 */


Tensor add(const Tensor& tensor1, const Tensor& tensor2) {
    TensorStorage::check_dimensions_elementwise(tensor1.storage, tensor2.storage);
    Tensor empty_tensor;
    if ((tensor1.isScalar() && tensor2.isScalar()) || (!tensor1.isScalar() && !tensor2.isScalar())) {
        empty_tensor = empty(
            tensor1.storage.ndim, tensor1.storage.dtype, tensor1.storage.strides, tensor1.storage.shape);
        AddTTKernel().execute(tensor1, tensor2, empty_tensor);
    } else if (tensor1.isScalar() && !tensor2.isScalar()) {
        empty_tensor = empty(
            tensor2.storage.ndim, tensor2.storage.dtype, tensor2.storage.strides, tensor2.storage.shape);
        AddTSKernel().execute(tensor2, tensor1, empty_tensor);
    } else {
        empty_tensor = empty(
            tensor1.storage.ndim, tensor1.storage.dtype, tensor1.storage.strides, tensor1.storage.shape);
        AddTSKernel().execute(tensor1, tensor2, empty_tensor);
    }
    
    return empty_tensor;
}



Tensor subtract(const Tensor& tensor1, const Tensor& tensor2) {
    TensorStorage::check_dimensions_elementwise(tensor1.storage, tensor2.storage);
    Tensor empty_tensor;
    if ((tensor1.isScalar() && tensor2.isScalar()) || (!tensor1.isScalar() && !tensor2.isScalar())) {
        empty_tensor = empty(
            tensor1.storage.ndim, tensor1.storage.dtype, tensor1.storage.strides, tensor1.storage.shape);
        SubTTKernel().execute(tensor1, tensor2, empty_tensor);
    } else if (tensor1.isScalar() && !tensor2.isScalar()) {
        empty_tensor = empty(
            tensor2.storage.ndim, tensor2.storage.dtype, tensor2.storage.strides, tensor2.storage.shape);
        SubTSKernel().execute(tensor2, tensor1, empty_tensor);
    } else {
        empty_tensor = empty(
            tensor1.storage.ndim, tensor1.storage.dtype, tensor1.storage.strides, tensor1.storage.shape);
        SubTSKernel().execute(tensor1, tensor2, empty_tensor);
    }
    
    return empty_tensor;
}



Tensor divide(const Tensor& tensor1, const Tensor& tensor2) {
    TensorStorage::check_dimensions_elementwise(tensor1.storage, tensor2.storage);
    Tensor empty_tensor;
    if ((tensor1.isScalar() && tensor2.isScalar()) || (!tensor1.isScalar() && !tensor2.isScalar())) {
        empty_tensor = empty(
            tensor1.storage.ndim, tensor1.storage.dtype, tensor1.storage.strides, tensor1.storage.shape);
        DivideTTKernel().execute(tensor1, tensor2, empty_tensor);
    } else if (tensor1.isScalar() && !tensor2.isScalar()) {
        empty_tensor = empty(
            tensor2.storage.ndim, tensor2.storage.dtype, tensor2.storage.strides, tensor2.storage.shape);
        DivideTSKernel().execute(tensor2, tensor1, empty_tensor);
    } else {
        empty_tensor = empty(
            tensor1.storage.ndim, tensor1.storage.dtype, tensor1.storage.strides, tensor1.storage.shape);
        DivideTSKernel().execute(tensor1, tensor2, empty_tensor);
    }
    
    return empty_tensor;
}



Tensor multiply(const Tensor& tensor1, const Tensor& tensor2) {
    TensorStorage::check_dimensions_elementwise(tensor1.storage, tensor2.storage);
    Tensor empty_tensor;
    if ((tensor1.isScalar() && tensor2.isScalar()) || (!tensor1.isScalar() && !tensor2.isScalar())) {
        empty_tensor = empty(
            tensor1.storage.ndim, tensor1.storage.dtype, tensor1.storage.strides, tensor1.storage.shape);
        MultiplyTTKernel().execute(tensor1, tensor2, empty_tensor);
    } else if (tensor1.isScalar() && !tensor2.isScalar()) {
        empty_tensor = empty(
            tensor2.storage.ndim, tensor2.storage.dtype, tensor2.storage.strides, tensor2.storage.shape);
        MultiplyTSKernel().execute(tensor2, tensor1, empty_tensor);
    } else {
        empty_tensor = empty(
            tensor1.storage.ndim, tensor1.storage.dtype, tensor1.storage.strides, tensor1.storage.shape);
        MultiplyTSKernel().execute(tensor1, tensor2, empty_tensor);
    }
    
    return empty_tensor;
}

/** end block **/

} // end ops

} // end sail

